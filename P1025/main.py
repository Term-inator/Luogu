# 读取输入的整数n和k
n, k = map(int, input().split())

# 创建一个二维数组dp来记录划分方案的数量
# dp[i][j]表示将整数i分成j份的方案数量
dp = [[0] * (k + 1) for _ in range(n + 1)]

# 初始化dp数组的边界条件
# 当i小于j时，无法将整数i分成j份，所以dp[i][j]为0
# 当i等于j或j等于1时，只有一种划分方案，即将整数i划分成j份的每份都是i本身
for i in range(1, n + 1):
    for j in range(1, k + 1):
        if i < j:
            dp[i][j] = 0
        if i == j or j == 1:
            dp[i][j] = 1

# 通过动态规划求解划分方案的数量
# 由于每份不能为空，所以在划分时，至少保留一个单位给第一份
# 所以从第二份开始，遍历整数i，将整数i划分成j份
# dp[i][j]可以分为两部分：
#   1. dp[i - 1][j - 1]表示将整数i的前i-1个数划分成j-1份的方案数量，因为这j-1份不包括i本身
#   2. dp[i - j][j]表示将整数i-j划分成j份的方案数量，因为这j份中包括一个单位给第一份，所以剩下的i-j就是i的第j份
# 将这两部分的方案数量相加即可得到dp[i][j]
for i in range(1, n + 1):
    for j in range(2, k + 1):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]

# 输出将整数n划分成k份的不同方案数量
print(dp[n][k])
